/* Copyright (c) 2006, Armin Biere, Johannes Kepler University. */

#define USAGE \
  "usage: cnfdd [-h] src dst cmd [<cmdopt> ...]\n" \
  "\n" \
  "  src   file name of an existing CNF in DIMACS format\n" \
  "  dst   file name of generated minimized CNF\n" \
  "  cmd   command to debug (expects a CNF file as argument)\n" \
  "\n" \
  "The delta debugger copies 'src' to 'dst' and tries to remove\n" \
  "as many clauses and literals without changing the exit code\n" \
  "of 'cmd dst'.  Then unused variables are removed, as long the\n" \
  "exit code does not change.\n"

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <limits.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

static const char * src;
static const char * dst;
static char * cmd;

static int ** clauses;
static int size_clauses;
static int maxidx;
static int * movedto;
static int expected;
static char tmp[100];

static void
die (const char * fmt, ...)
{
  va_list ap;
  fputs ("*** cnfdd: ", stderr);
  va_start (ap, fmt);
  vfprintf (stderr, fmt, ap);
  va_end (ap);
  fputc ('\n', stderr);
  fflush (stderr);
  if (tmp[0] == '/')
    unlink (tmp);
  exit (1);
}

static void
msg (const char * fmt, ...)
{
  va_list ap;
  fputs ("[cnfdd] ", stderr);
  va_start (ap, fmt);
  vfprintf (stderr, fmt, ap);
  va_end (ap);
  fputc ('\n', stderr);
  fflush (stderr);
}

static void
parse (void)
{
  int i, ch, * clause, lit, sign, size_clause, count_clause, count_clauses;
  FILE * file = fopen (src, "r");

  if (!file)
    die ("can not read from '%s'", src);

SKIP:
  ch = getc (file);
  if (isspace (ch))
    goto SKIP;

  if (ch == 'c')
    {
      while ((ch = getc (file)) != '\n' && ch != EOF)
	;
      goto SKIP;
    }

  if (ch != 'p' || fscanf (file, " cnf %d %d", &maxidx, &size_clauses) != 2)
    die ("expected 'p cnf ...' header");

  movedto = malloc ((maxidx + 1) * sizeof (movedto[0]));
  for (i = 1; i <= maxidx; i++)
    movedto[i] = i;

  clauses = malloc (size_clauses * sizeof (clauses[0]));

  clause = 0;
  size_clause = count_clause = count_clauses = 0;

NEXT:

  ch = getc (file);
  if (isspace (ch))
    goto NEXT;

  if (ch == 'c')
    {
      while ((ch = getc (file)) != '\n' && ch != EOF)
	;
      goto NEXT;
    }

  if (ch == '-')
    {
      sign = -1;
      ch = getc (file);
      if (ch == EOF)
	die ("EOF after '-'");
    }
  else
    sign = 1;

  if (ch != EOF && !isdigit (ch))
    die ("invalid character %02x", ch);

  if (isdigit (ch))
    {
      lit = ch - '0';
      while (isdigit (ch = getc (file)))
	lit = 10 * lit + (ch - '0');

      lit *= sign;

      if (count_clause == size_clause)
	{
	  size_clause = size_clause ? 2 * size_clause : 1;
	  clause = realloc (clause, size_clause * sizeof (clause[0]));
	}

      clause[count_clause++] = lit;

      if (!lit)
	{
	  if (count_clauses == size_clauses)
	    die ("too many clauses");

	  clauses[count_clauses++] = clause;
	  count_clause = size_clause = 0;
	  clause = 0;
	}

      goto NEXT;
    }

  assert (ch == EOF);

  if (count_clause)
    die ("missing '0' after clause");

  if (count_clauses < size_clauses)
    die ("%d clauses missing", size_clauses - count_clauses);

  assert (!clause);
  fclose (file);

  msg ("parsed %d variables", maxidx);
  msg ("parsed %d clauses", size_clauses);
}

static int
run (const char * name)
{
  char * buffer = malloc (strlen (cmd) + strlen (name) + 100);
  int res;

  /* TODO if this command produces a lot of output, e.g. a solution
   * to a SAT problem, then flushing the associated output buffers of
   * the process generated by 'system' seems to take quiet some time.
   * It is probably better to directly use 'exec' and redirect output
   * in such a way that it does not have to go through the pipe.  Of course
   * users can avoid this effect by not letting the command produce much
   * output through adding appropriate command line options.
   */
  sprintf (buffer, "exec %s %s 1>/dev/null 2>/dev/null", cmd, name);
  res = system (buffer);
  free (buffer);
  res = WEXITSTATUS (res);
  return res;
}

static int
keptvariables (void)
{
  int i, j, idx, res;

  res = 0;
  for (i = 0; i < size_clauses; i++)
    {
      if (!clauses[i])
	continue;

      j = 0;
      while ((idx = abs (clauses[i][j++])))
	{
	  if (idx == INT_MAX)
	    continue;

	  idx = movedto[idx];
	  if (idx > res)
	    res = idx;
	}
    }

  return res;
}

static int
keptclauses (void)
{
  int i, res;

  res = 0;
  for (i = 0; i < size_clauses; i++)
    if (clauses[i])
      res++;

  return res;
}

static void
print (const char * name)
{
  FILE * file = fopen (name, "w");
  int i, j, lit, idx;

  if (!file)
    die ("can not write to '%s'", name);

  fprintf (file, "p cnf %d %d\n", keptvariables (), keptclauses ());

  for (i = 0; i < size_clauses; i++)
    {
      if (!clauses[i])
	continue;

      j = 0;
      while ((lit = clauses[i][j++]))
	{
	  if (lit == INT_MAX)
	    continue;

	  idx = abs (lit);
	  idx = movedto[idx];
	  lit = (lit < 0) ? -idx : idx;

	  fprintf (file, "%d ", lit);
	}

      fputs ("0\n", file);
    }

  fclose (file);
}

static void
setup (void)
{
  msg ("copied '%s' to '%s'", src, dst);
  print (dst);
  expected = run (dst);
  msg ("expected exit code is %d", expected);
  sprintf (tmp, "/tmp/cnfdd-%u", (unsigned) getpid ());
}

static void
save (void)
{
  print (dst);
  msg ("saved intermediate result in '%s'", dst);
}

static void
reduce (void)
{
  int bytes = size_clauses * sizeof (int);
  int i, j, end, width, found, removed, total;
  int ** saved = malloc (bytes);

  width = size_clauses;
  total = 0;

  while (width)
    {
      if (!isatty (2))
	msg ("delta width %d", width);

      removed = 0;
      i = 0;

      do {

	if (isatty (2))
	  {
	    fprintf (stderr,
		     "[cnfdd] delta width %d completed %d/%d\r", 
		     width, i, size_clauses);

	    fflush (stderr);
	  }

	end = i + width;
	if (end > size_clauses)
	  end = size_clauses;

	found = 0;
	for (j = i; j < end; j++)
	  {
	    if (clauses[j])
	      {
		found++;
		saved[j] = clauses[j];
		clauses[j] = 0;
	      }
	    else
	      saved[j] = 0;
	  }

	if (found)
	  {
	    print (tmp);

	    if (run (tmp) == expected)
	      {
		for (j = i; j < end; j++)
		  {
		    if (saved[j])
		      {
			total++;
			removed++;
			free (clauses[j]);
		      }
		  }
	      }
	    else
	      {
		for (j = i; j < end; j++)
		  clauses[j] = saved[j];
	      }
	  }

	i = end;

      } while (i < size_clauses);

      if (isatty (2))
	{
	  fputc ('\r', stderr);
	  for (i = 0; i < 79; i++)
	    fputc (' ', stderr);
	  fputc ('\r', stderr);

	  msg ("delta width %d", width);
	}

      if (removed)
	{
	  msg ("removed %d clauses", removed);
	  save ();
	}

      width /= 2;
    }

  free (saved);

}

static void
shrink (void)
{
}

static void
move (void)
{
  char * used = malloc (maxidx + 1);
  int i, j, idx, count, * saved, movedtomaxidx;

  for (i = 1; i <= maxidx; i++)
    used[i] = 0;

  for (i = 0; i < size_clauses; i++)
    {
      if (!clauses[i])
	continue;

      j = 0;
      while ((idx = abs (clauses[i][j++])))
	used[idx] = 1;
    }

  movedtomaxidx = 0;
  count = 0;
  for (i = 1; i <= maxidx; i++)
    {
      if (!used[i])
	continue;

      if (movedto[i] > movedtomaxidx)
	movedtomaxidx = movedto[i];

      count++;
    }

  if (count && count < movedtomaxidx)
    {
      saved = malloc ((maxidx + 1) * sizeof (saved[0]));
      for (i = 1; i <= maxidx; i++)
	saved[i] = movedto[i];

      j = 0;
      for (i = 1; i <= maxidx; i++)
	if (used[i])
	  movedto[i] = ++j;

      assert (j == count);

      print (tmp);
      if (run (tmp) == expected)
	{
	  msg ("removed %d variables", movedtomaxidx - count);
	  save ();
	  assert (run (dst) == expected);
	}
      else
	{
	  for (i = 1; i <= maxidx; i++)
	    movedto[i] = saved[i];
	}

      free (saved);
    }

  free (used);
}

static void
reset (void)
{
  int i;
  for (i = 0; i < size_clauses; i++)
    free (clauses[i]);
  free (clauses);
  free (movedto);
  free (cmd);
  unlink (tmp);
}

int
main (int argc, char ** argv)
{
  int i;

  for (i = 1; i < argc; i++)
    {
      if (!cmd)
	{
	  if (!strcmp (argv[i], "-h"))
	    {
	      printf ("%s", USAGE);
	      exit (0);
	    }

	  if (argv[i][0] == '-')
	    die ("invalid command line option '%s'", argv[i]);
	}

      if (cmd)
	{
	  char * old = cmd;
	  cmd = malloc (strlen (old) + 1 + strlen (argv[i]) + 1);
	  sprintf (cmd, "%s %s", old, argv[i]);
	  free (old);
	}
      else if (dst)
	cmd = strdup (argv[i]);
      else if (src)
	dst = argv[i];
      else
	src = argv[i];
    }

  if (!src)
    die ("'src' missing");

  if (!dst)
    die ("'dst' missing");

  if (!cmd)
    die ("'cmd' missing");

  parse ();
  setup ();
  reduce ();
  move ();
  shrink ();
  move ();

  msg ("kept %d variables", keptvariables ());
  msg ("kept %d clauses", keptclauses ());

  reset ();

  return 0;
}
